initSidebarItems({"enum":[["AttributeBitFlags","Bit flags used in `flags0` column in temporary tables created during search, such as the `search_results`, `inexact_searches` and `exact_searches` tables. When moving to a more concrete table, such as `datoms`, they are expanded out via these flags and put into their own column rather than a bit field."],["Binding","The values bound in a query specification can be:"],["SQLTypeAffinity","Type safe representation of the possible return values from SQLite's `typeof`"],["TypedValue","Represents a value that can be stored in a Mentat store."],["ValueType","The attribute of each Mentat assertion has a :db/valueType constraining the value to a particular set.  Mentat recognizes the following :db/valueType values."]],"fn":[["now","Return the current time as a UTC `DateTime` instance with microsecond precision."],["parse_query",""]],"macro":[["interpose","A helper macro to sequentially process an iterable sequence, evaluating a block between each pair of items."],["interpose_iter","A helper to bind `name` to values in `across`, running `body` for each value, and running `inter` between each value. See `interpose` for examples."]],"mod":[["attribute",""],["counter",""],["intern_set",""],["util",""],["values",""]],"struct":[["Attribute","A Mentat schema attribute has a value type and several other flags determining how assertions with the attribute are interpreted."],["DateTime","ISO 8601 combined date and time with time zone."],["EdnParseError",""],["Keyword","A keyword is a symbol, optionally with a namespace, that prints with a leading colon. This concept is imported from Clojure, as it features in EDN and the query syntax that we use."],["KnownEntid","An entid that's either already in the store, or newly allocated to a tempid. TODO: we'd like to link this in some way to the lifetime of a particular PartitionMap."],["Schema","Represents a Mentat schema."],["StructuredMap","A pull expression expands a binding into a structure. The returned structure associates attributes named in the input or retrieved from the store with values. This association is a `StructuredMap`."],["Utc","The UTC time zone. This is the most efficient time zone when you don't need the local time. It is also used as an offset (which is also a dummy type)."],["Uuid","A Universally Unique Identifier (UUID)."],["ValueTypeSet",""]],"trait":[["CachedAttributes",""],["Cloned",""],["FromMicros",""],["FromRc",""],["HasSchema",""],["SQLValueType",""],["SQLValueTypeSet","We have an enum of types, `ValueType`. It can be collected into a set, `ValueTypeSet`. Each type is associated with a type tag, which is how a type is represented in, e.g., SQL storage. Types can share type tags, because backing SQL storage is able to differentiate between some types (e.g., longs and doubles), and so distinct tags aren't necessary. That association is defined by `SQLValueType`. That trait similarly extends to `ValueTypeSet`, which maps a collection of types into a collection of tags."],["Timelike","The common set of methods for time component."],["ToMicros",""],["UpdateableCache",""]],"type":[["AttributeMap","Map attribute entids to `Attribute` instances."],["Entid","Represents one entid in the entid space."],["EntidMap","Map positive integer entids (`1`) to `Keyword` idents (`:db/ident`)."],["IdentMap","Map `Keyword` idents (`:db/ident`) to positive integer entids (`1`)."],["ValueRc","This type alias exists to allow us to use different boxing mechanisms for values. This type must implement `FromRc` and `Cloned`, and a `From` implementation must exist for `TypedValue`."],["ValueTypeTag",""]]});